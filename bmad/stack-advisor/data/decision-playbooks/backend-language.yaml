# Backend Language Selection Playbook
# Flowchart-style decision tree for choosing the right backend language/framework

playbook:
  name: "Backend Language & Framework Selection"
  description: "Step-by-step guide to selecting the optimal backend technology"
  version: "1.0"
  last_updated: "2025-01-14"

decision_tree:
  start:
    question: "What type of backend are you building?"
    options:
      - label: "REST API for web/mobile app"
        next: "rest_api"
      - label: "Real-time application (WebSocket, live updates)"
        next: "realtime"
      - label: "Microservices architecture"
        next: "microservices"
      - label: "Simple CRUD API"
        next: "simple_crud"
      - label: "Data processing / background jobs"
        next: "data_processing"
      - label: "Serverless functions"
        next: "serverless"

  rest_api:
    question: "What's your team's experience?"
    context: "REST APIs are the most common backend pattern"
    options:
      - label: "JavaScript/TypeScript (Node.js)"
        next: "nodejs_rest"
      - label: "Python"
        next: "python_rest"
      - label: "Go"
        next: "go_rest"
      - label: "Ruby"
        next: "ruby_rest"
      - label: "No backend experience yet"
        next: "beginner_backend"

  nodejs_rest:
    question: "What's your priority?"
    options:
      - label: "Speed and simplicity"
        recommendation: "Fastify or Hono"
        rationale: "Fastest Node.js frameworks, minimal overhead, great DX"
        next: null
      - label: "Maturity and ecosystem"
        recommendation: "Express.js"
        rationale: "Most mature, huge ecosystem, tons of middleware"
        next: null
      - label: "Type safety and structure"
        recommendation: "NestJS"
        rationale: "TypeScript-first, Angular-like structure, great for teams"
        next: null
      - label: "Edge deployment"
        recommendation: "Hono"
        rationale: "Runs on Cloudflare Workers, Deno, Bun, Node.js - ultra portable"
        next: null

  python_rest:
    question: "What's your priority?"
    options:
      - label: "Speed and modern async"
        recommendation: "FastAPI"
        rationale: "Modern, fast, automatic API docs, great type hints"
        next: null
      - label: "Full-featured framework"
        recommendation: "Django + Django REST Framework"
        rationale: "Batteries included, admin panel, ORM, mature ecosystem"
        next: null
      - label: "Simplicity and flexibility"
        recommendation: "Flask"
        rationale: "Minimal, flexible, easy to learn, good for small APIs"
        next: null

  go_rest:
    question: "What's your priority?"
    options:
      - label: "Maximum performance"
        recommendation: "Fiber or Echo"
        rationale: "Extremely fast, low memory, excellent concurrency"
        next: null
      - label: "Simplicity"
        recommendation: "Gin"
        rationale: "Minimal, fast, good balance of features and simplicity"
        next: null
      - label: "Minimal dependencies"
        recommendation: "net/http (stdlib) or Chi"
        rationale: "Standard library is powerful, Chi adds minimal routing"
        next: null

  ruby_rest:
    question: "What's your use case?"
    options:
      - label: "Full web application with API"
        recommendation: "Ruby on Rails (API mode)"
        rationale: "Mature, productive, great conventions, excellent ecosystem"
        next: null
      - label: "Lightweight API only"
        recommendation: "Sinatra or Grape"
        rationale: "Minimal overhead, just what you need"
        next: null

  beginner_backend:
    question: "What do you already know?"
    context: "Build on existing knowledge when learning backend"
    options:
      - label: "JavaScript (from frontend)"
        recommendation: "Express.js or Fastify"
        rationale: "Leverage JS knowledge, easy learning curve, huge resources"
        next: null
      - label: "Python (from data science/scripts)"
        recommendation: "FastAPI or Flask"
        rationale: "Modern, easy to learn, great docs, growing ecosystem"
        next: null
      - label: "Nothing yet, complete beginner"
        recommendation: "Express.js or FastAPI"
        rationale: "Best learning resources, active communities, easy to understand"
        next: null

  realtime:
    question: "What's the scale and complexity?"
    context: "Real-time requires WebSocket support or SSE"
    options:
      - label: "Simple real-time features (chat, notifications)"
        next: "simple_realtime"
      - label: "Complex real-time (multiplayer game, collaborative editing)"
        next: "complex_realtime"
      - label: "Just need live database updates"
        recommendation: "Supabase or Firebase"
        rationale: "Built-in real-time subscriptions, no backend code needed"
        next: null

  simple_realtime:
    question: "What language do you prefer?"
    options:
      - label: "JavaScript/TypeScript"
        recommendation: "Node.js with Socket.io"
        rationale: "Battle-tested, easy WebSocket abstraction, great DX"
        next: null
      - label: "Python"
        recommendation: "FastAPI with WebSockets"
        rationale: "Modern async support, WebSocket support built-in"
        next: null
      - label: "Go"
        recommendation: "Gorilla WebSocket or Melody"
        rationale: "Excellent concurrency, handles many connections efficiently"
        next: null

  complex_realtime:
    question: "What's your primary concern?"
    options:
      - label: "Maximum concurrent connections"
        recommendation: "Go (Gorilla WebSocket) or Elixir (Phoenix)"
        rationale: "Go: goroutines handle millions of connections; Elixir: BEAM VM designed for this"
        next: null
      - label: "Developer experience"
        recommendation: "Node.js with Socket.io"
        rationale: "Easiest to develop, good scaling story, huge ecosystem"
        next: null
      - label: "State synchronization"
        recommendation: "Elixir Phoenix or Node.js with Yjs"
        rationale: "Phoenix Presence for state; Yjs for CRDT-based sync"
        next: null

  microservices:
    question: "What's your team size and experience?"
    context: "Microservices add complexity - ensure you need them"
    options:
      - label: "Small team (< 5), reconsidering microservices"
        recommendation: "Start with Monolith (modular design)"
        rationale: "Microservices are complex - most SMBs don't need them yet"
        next: null
      - label: "Need polyglot services"
        next: "polyglot_micro"
      - label: "All one language, need service isolation"
        next: "monoglot_micro"

  polyglot_micro:
    question: "What's your primary language?"
    context: "Use best tool for each service, with coordination"
    options:
      - label: "Mostly Node.js"
        recommendation: "Node.js + Go for performance-critical services"
        rationale: "Node for business logic, Go for heavy computation/concurrency"
        next: null
      - label: "Mostly Python"
        recommendation: "Python + Go for performance-critical services"
        rationale: "Python for ML/data, Go for API gateways and high-throughput"
        next: null
      - label: "Mostly Go"
        recommendation: "Go for everything"
        rationale: "Go handles all use cases well - avoid unnecessary polyglot complexity"
        next: null

  monoglot_micro:
    question: "Which language?"
    options:
      - label: "Node.js/TypeScript"
        recommendation: "NestJS with microservices modules"
        rationale: "Built-in microservices support, shared types, good structure"
        next: null
      - label: "Python"
        recommendation: "FastAPI with async workers"
        rationale: "Modern async, can use Celery for background tasks"
        next: null
      - label: "Go"
        recommendation: "Go with go-kit or go-micro"
        rationale: "Excellent for microservices, fast, great concurrency"
        next: null

  simple_crud:
    question: "Do you need an admin panel?"
    context: "Simple CRUD benefits from frameworks with built-in admin"
    options:
      - label: "Yes, need admin UI"
        recommendation: "Django or Strapi"
        rationale: "Django has excellent admin; Strapi is headless CMS with admin"
        next: null
      - label: "No admin needed"
        next: "simple_crud_no_admin"

  simple_crud_no_admin:
    question: "What's your frontend?"
    options:
      - label: "Next.js or React"
        recommendation: "Next.js API Routes or tRPC"
        rationale: "Keep frontend and backend together, type-safe with tRPC"
        next: null
      - label: "Separate frontend app"
        recommendation: "FastAPI or Express"
        rationale: "Quick to build, automatic docs (FastAPI), easy deployment"
        next: null
      - label: "Mobile app"
        recommendation: "Supabase or FastAPI"
        rationale: "Supabase is instant API; FastAPI is fast to build custom"
        next: null

  data_processing:
    question: "What type of processing?"
    context: "Different languages excel at different processing tasks"
    options:
      - label: "Data analysis / ML pipelines"
        recommendation: "Python (pandas, scikit-learn, etc.)"
        rationale: "Best ML ecosystem, notebook support, data science libraries"
        next: null
      - label: "Heavy computation / parallel processing"
        recommendation: "Go or Rust"
        rationale: "Excellent concurrency, low memory, fast execution"
        next: null
      - label: "ETL / Data transformation"
        recommendation: "Python or Node.js"
        rationale: "Python for complex transforms; Node.js for streaming data"
        next: null
      - label: "Background jobs / queues"
        next: "background_jobs"

  background_jobs:
    question: "What's your main application language?"
    options:
      - label: "Node.js"
        recommendation: "BullMQ or Inngest"
        rationale: "BullMQ for Redis-backed queues; Inngest for serverless jobs"
        next: null
      - label: "Python"
        recommendation: "Celery or Temporal"
        rationale: "Celery for traditional jobs; Temporal for complex workflows"
        next: null
      - label: "Go"
        recommendation: "Asynq or Temporal"
        rationale: "Asynq for simple queues; Temporal for workflows"
        next: null

  serverless:
    question: "What's your deployment target?"
    context: "Different platforms have different language support"
    options:
      - label: "Vercel"
        recommendation: "Next.js API Routes or Node.js"
        rationale: "Native Next.js support, optimized for Vercel"
        next: null
      - label: "AWS Lambda"
        next: "aws_lambda"
      - label: "Cloudflare Workers"
        recommendation: "Hono or itty-router"
        rationale: "Edge-optimized, ultra-fast cold starts, global deployment"
        next: null
      - label: "Supabase Edge Functions"
        recommendation: "Deno with TypeScript"
        rationale: "Runs on Deno runtime, TypeScript-first"
        next: null

  aws_lambda:
    question: "What's your priority?"
    options:
      - label: "Fast cold starts"
        recommendation: "Node.js or Python"
        rationale: "Fastest cold start times in Lambda"
        next: null
      - label: "Performance in warm state"
        recommendation: "Go or Rust"
        rationale: "Fastest execution, lowest memory"
        next: null
      - label: "Easiest development"
        recommendation: "Node.js or Python"
        rationale: "Best local development experience, most Lambda examples"
        next: null

# Quick reference matrix
quick_reference:
  by_use_case:
    rest_api_web: "FastAPI or Express/Fastify"
    rest_api_mobile: "FastAPI or NestJS"
    graphql_api: "Apollo Server (Node.js) or Strawberry (Python)"
    websocket_server: "Node.js Socket.io or Go"
    crud_with_admin: "Django or Strapi"
    microservices: "Go or NestJS"
    data_processing: "Python"
    serverless: "Node.js or Go"

  by_team_skill:
    javascript_team: "Node.js (Express, Fastify, or NestJS)"
    python_team: "FastAPI or Django"
    polyglot_team: "Go (easy to learn, performs well)"
    beginner_team: "Express or FastAPI"

  by_priority:
    performance: "Go or Rust"
    developer_productivity: "Django or Rails"
    type_safety: "NestJS or Go"
    async_io: "Node.js, FastAPI, or Go"
    learning_curve: "Express or Flask"
    job_market: "Node.js or Python"

  by_scale:
    small_0_1k_users: "Express, FastAPI, or BaaS (Supabase)"
    medium_1k_100k: "Fastify, FastAPI, or NestJS"
    large_100k_plus: "Go, Java/Spring Boot, or .NET"

# Common decision patterns
patterns:
  greenfield_saas_backend:
    recommendation: "FastAPI or NestJS"
    rationale: "Modern, type-safe, great DX, scales well"
    stack: ["FastAPI + PostgreSQL + Redis" , "NestJS + PostgreSQL + Redis"]

  api_for_mobile_app:
    recommendation: "Supabase or FastAPI"
    rationale: "Supabase = instant backend; FastAPI = custom with auto-docs"
    stack: ["Supabase (BaaS)", "FastAPI + PostgreSQL"]

  existing_frontend_needs_api:
    recommendation: "Match frontend language if possible"
    rationale: "Shared types, easier hiring, code reuse"
    examples:
      next_js: "Next.js API Routes or tRPC"
      react_separate: "Express or FastAPI"

  data_heavy_app:
    recommendation: "Python (FastAPI or Django)"
    rationale: "Best data libraries, easy ML integration"
    stack: ["FastAPI + PostgreSQL + Celery + Redis"]

  real_time_app:
    recommendation: "Node.js Socket.io or Supabase"
    rationale: "Socket.io = custom real-time; Supabase = instant real-time"
    stack: ["Node.js + Socket.io + Redis", "Supabase"]

# Red flags (when NOT to use specific languages)
red_flags:
  nodejs:
    - "CPU-intensive tasks (video processing, heavy computation)"
    - "Need very predictable latency (GC pauses)"

  python:
    - "Need maximum performance (raw speed)"
    - "Ultra-high concurrency requirements"

  go:
    - "Rapid prototyping (less productive than Python/Node initially)"
    - "Heavy use of external libraries (ecosystem smaller than Node/Python)"

  ruby:
    - "Need maximum performance"
    - "Hiring is critical and market is small"

  java:
    - "Small team (< 3 developers)"
    - "Simple API (too heavy)"
    - "Need rapid iteration"

  php:
    - "Modern team expecting modern tooling"
    - "Heavy real-time requirements"

# SMB-specific guidance
smb_guidance:
  micro_business_1_2_people:
    recommendation: "Express, FastAPI, or Supabase"
    rationale: "Quick to build, easy to maintain, can handle solo"

  small_business_3_10_people:
    recommendation: "FastAPI, NestJS, or Django"
    rationale: "Balance of structure and flexibility, easy hiring"

  avoid_for_smb:
    - "Java/Spring Boot (too heavy for SMB)"
    - "Microservices (complexity not worth it)"
    - ".NET (unless Windows-centric org)"
    - "Elixir/Phoenix (hiring challenges)"
    - "Custom frameworks (use proven solutions)"

# Framework combinations (backend + database + cache)
recommended_stacks:
  modern_node_api:
    backend: "Fastify or NestJS"
    database: "PostgreSQL"
    orm: "Prisma or Drizzle"
    cache: "Redis"
    queue: "BullMQ"

  modern_python_api:
    backend: "FastAPI"
    database: "PostgreSQL"
    orm: "SQLAlchemy or SQLModel"
    cache: "Redis"
    queue: "Celery"

  golang_api:
    backend: "Gin or Fiber"
    database: "PostgreSQL"
    orm: "GORM or sqlc"
    cache: "Redis"
    queue: "Asynq"

  rapid_mvp:
    backend: "Supabase or Firebase"
    database: "Built-in (Postgres or Firestore)"
    cache: "Built-in"
    queue: "Supabase Edge Functions"

# Performance characteristics
performance_comparison:
  requests_per_second:
    go: "Very High (50k+ req/s)"
    nodejs_fastify: "High (30k+ req/s)"
    python_fastapi: "Medium-High (10k+ req/s)"
    ruby_rails: "Medium (5k+ req/s)"
    python_django: "Medium (5k+ req/s)"

  memory_usage:
    go: "Very Low (10-50 MB)"
    nodejs: "Medium (50-150 MB)"
    python: "Medium-High (100-300 MB)"
    ruby: "High (150-400 MB)"

  cold_start_serverless:
    nodejs: "Very Fast (< 100ms)"
    python: "Fast (< 200ms)"
    go: "Fast (< 200ms compiled)"
    java: "Slow (500ms-2s)"

  developer_productivity:
    rails: "Very High"
    django: "High"
    express: "High"
    nestjs: "Medium-High"
    go: "Medium"
